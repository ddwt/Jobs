##U3D面经
####1. 渲染管线
>答：分为四个步骤：顶点变换，图元装配，光栅化，像素处理
>顶点变换：通过一系列的左边系转换，将模型的顶点在摄像机前进行位移，并最终投影到摄像机的投影屏幕上。转换完了以后再进行雾化、材质属性、和光照处理等
>图元装配，包括剔除、截取等。剔除包括正面剔除、反面剔除等，剔除是为了效率考虑，剔除有些显示不到的面，剔除后的话，不会再进行其他运算了
>光栅化：屏幕坐标是浮点数，像素坐标是整数，这里面转换就是光栅化
>像素处理：对每个像素区域进行着色、对像素贴上贴图
####2. Bloom特效
>答：又称全屏泛光，使用后，画面的对比会得到增强，亮的地方曝光也会得到加强
>实现流程：第一步获取屏幕图像，然后对每个像素进行亮度检测，若大于某个阀值即保留原始颜色值，否则置为黑色；第二步：对上一步获取的图像，做一个模糊，通常使用高斯模糊，第三部将模糊后的图片和原图片做一个加权和
####3. 卡通渲染
>答：卡通风格渲染的画面通常物体颜色分界明显，具有黑色的线条描边。卡通渲染的实现有多种方法，基于色调的着色技术是其中之一，实现过程中通过使用漫反射系数对一维纹理进行采样，控制漫反射色调。
####4. 简述动态加载资源的方式和区别？
>答：1. 通过Resources模块，调用它的load函数，可以直接load并返回某个类型的Object,前提是要把这个资源放在Resource命名的文件夹下，Unity不管有没有场景引用，都会将其全部打入到安装包中
>2. 通过bundle形式：即将资源打成asset bundle放在服务器或本地磁盘，然后使用WWW模块get下来，然后从这个bundle中load某个object。
>3. 通过AssetDatabase.loadasset：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是开发中调试用的
>区别：Resources的方式需要把所有资源全部打入安装包，这对游戏的分包发布和版本升级是不利的，所以unity推荐的方式是不用它，都用bundle的方式代替，把资源打成几个小的bundle，用哪个就load哪个，这样还能分包发布和patch，但是在开发过程中，不可能更新一个资源就打一次bundle，所以editor环境下可以使用AssetDatabase来模拟，这通常需要我们封装一个dynamic resource的loader模块，不同的环境下不同的实现
>动态资源的存放：在编辑器建立一个StreamingAssets名字的文件夹
####6. c#中的委托是什么？事件是不是一种委托？
>答：委托是一种安全的类似与函数指针，但是它比函数指针安全，它可以把方法作为一个参数传递给另一个方法，可以理解为指向函数的引用。事件是一种消息机制，它是一种委托，委托不带方法体，事件将调用的方法分离出来，用信号代表，当需求变动时，改个注册事件就行了。
####7. StringBuilder与String的区别？
>答：String本身不可改变，它只能赋值一次，每一次内容发生改变，都会生成一个新的对象，然后原有的对象引用新的对象，而每一次生成新对象都会对系统性能产生影响，这会降低.NET编译器的工作效率，而StringBuilder类则不同，每次操作都是对自身对象进行操作，而不是生成新的对象，其所占空间会随着内容的增加而扩充。
####8. Unity如何内存优化？
>1. 压缩自带类库
>2. 将暂时不用的以后还需要使用的物体隐藏而不destroy
>3. 释放AssetBundle占用的资源，AssetBundle资源包
>4. 降低模型的片面数，降低模型的骨骼数量，降低贴图的大小
>5. 使用光照贴图，使用多层次细节（LOD），使用着色器，使用预制体
####9. unity3d中的碰撞器和触发器的区别？
>答：触发器知识碰撞器上的一个属性，碰撞器是触发器的载体
>碰撞器有碰撞效果，IsTrigger = false, 调用OnCollisionEnter函数
>触发器没有碰撞效果，IsTrigger = true，调用OnTriggerEnter
####10. Unity3d的物理引擎中，有几种施加力的方式，分别描述出来？
>答：都在rigidbody系列函数中，AddForce和AddForceAtPosition
####11. 什么叫链条关节？
>答：Hinge Joint，可以模拟两个物体间用一根链条连接在一起，能保持两个物体在一个固定距离内相互移动而不产生作用力，但是达到固定距离后就会产生拉力
####12. Unity3d提供了几种光源类型，分别是哪几种？
>答：四种，平行光，点光源，聚光灯，区域光源
####13.Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。
>答：Awake->OnEnable—>Start—>FixedUpdate—>Update—>LateUpdate—>OnGUI—>Reset—>OnDisable—>OnDestroy
>Reset：在用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。
>Awake（一次）：Awake在所有对象被初始化之后调用，用于在游戏开始之前初始化变量
>或游戏状态。在脚本整个生命周期内Awake仅被调用一次。Awake不能用来执行协同程
>序。每个游戏物体上的Awake以随机的顺序被调用。所以在一般时候，用Awake来设置脚
>本间的引用，然后用Start来传递信息。
>OnEnable：在Awake之后调用。控制脚本中组件的启动与禁用。例如：
>this.enable=false，则会直接跳转到OnDisable方法执行一次，其它的任何方法，将不再被
>执行。
>Start（一次）：Start函数总是在Awake函数之后调用。Start在生命周期中只被调用一》
> 次。Start和Awake的不同是Start只在脚本实例被启用时调用。你可以按需调整延迟初始
> 化代码，协调初始化顺序。
>FixedUpdate（每帧）：固定帧（固定的时间间隔，不受帧率(FPS)影响）更新，更新频率默认为0.02s。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。
>Update（每帧）：正常帧更新，每一帧都执行，用于更新逻辑。Update比较适合做控
>制。如果卡帧了Update就不会再执行，而FixedUpdate则继续执行。
>LateUpdate（每帧）：在所有Update函数调用后被调用，和fixedupdate一样都是每一帧
>都被调用执行。LateUpdate可用于调整脚本执行顺序。例如：相机跟随就可以用这个函
>数，即人物移动在Update中实现，相机跟随在LateUpdate()中实现，播放后的效果是：角
>色移动发生在前，相机移动紧跟其后。（如果相机也在Update里执行，就可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。）
>OnGUI（每帧）在渲染和处理GUI事件时调用。每帧都执行。在界面显示一个button或
>label时常常用到它。
>OnDisable：脚本被卸载时，OnDisable将被调用（脚本不会被销毁）。OnDisable不能用
>于协同程序。常用于一些用于清理的事件。
>OnDestroy：当MonoBehaviour将被销毁时，这个函数被调用。OnDestroy只会在预先已经
>被激活的游戏物体上被调用。OnDestroy也不能用于协同程序。
#### 14. 说出四种面向对象的设计原则，简述含义
>答：1 单一指责原则：一个类最好只做一件事，只有一个引起它的变化，类被修改的几率很大，如果把多个功能放在同一个类中，功能之间就形成了管理
>开放-封闭原则：对于扩展是开放的，对于更改是封闭的，即在设计一个模块的时候，应当使这个模块可以在不修改的前提下被扩展，封闭是当模块被其他模块调用时不能被修改
>2 里式替换原则：子类必须能够替换其基类
>3 依赖倒置原则：要依赖于抽象，不依赖于具体的实现，高层模块不应该依赖于低层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节依赖抽象
>具体实现：
>1） 通过构造函数传递依赖对象
>2） 通过setter方法传递依赖对象
>3） 接口声明实现依赖对象
>4 接口隔离原则：使用多个小的专门的接口，而不要使用一个大的总接口
>实现方法；
>1） 使用委托分离接口
>2） 使用多重继承分离接口
#### 15. 说出对Animation和Animator的理解
>答：Animation和Animator虽然都是控制动画的播放，但是它们的用法和相关语法都是大有不同的。Animation控制一个动画的播放，而Animator是多个动画之间相互切换，并且Animator有一个动画状态机，Animator的优点是切换方便，缺点是内存比较大
#### 16. 简述值类型和引用类型的区别？
> 答：1）值类型存储在栈中，引用类型存在堆中，而内存单元中存放的是堆中存放的数据
> 2） 值类型存取快，引用类型存取慢
> 3） 值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用
> 4） 栈的内存是自动释放的，堆内存是.NET中会由GC自动释放
> 5） 值类型继承自System.ValueType，引用类型继承自System.Object
#### 17. 简述ArrayList和List<>的主要区别？
>答：
