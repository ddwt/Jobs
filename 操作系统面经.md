## 操作系统
#### 1. 进程和线程的区别是什么？
>答：1 进程是CPU分配的最小单位，线程是CPU调度的基本单元
>2 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，简历数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多
>3 线程之间通信更方便，同一进程下的线程共享全局变量，静态变量等数据，而进程之间的通信需要以通信的方式（IPC）进行
>4 但是多进程程序更健壮，多线程只要一个线程死掉，整个进程也死掉了，而一个进程死掉不会对其他有影响，因为进程有独立内存
#### 2. 进程间通信的方式是什么？线程间通信方式是什么？
>答；进程间通信可以通过socket，管道，信号，消息，共享内存等多种方式，线程间通信比较简单，直接共享变量也可以通过管道
#### 3. 四种线程同步的方法？
>答：临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问
>互斥量：为协调一起对一个共享资源的单独访问而设计的
>信号量；为控制一个具备有限数量用户资源而设计
>事件：用来通知线程有一些事件已发生，从而启动后继任务的开始
#### 4. 什么是缓存，有哪些缓存的更新算法？
>答：缓存：凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称为缓存(Cache)，CPU从Cache中读取到有用数据称为“命中”
>缓存算法：LFU，根据数据的历史访问频率来淘汰数据，核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”
>缓存算法：LRU，根据数据的历史访问记录来淘汰数据，核心思想是“如果数据最近被访问过，那么将来被访问的频率也更高”
>缓存算法：FIFO，最先进入的数据，最先被淘汰，用队列就能实现，核心思想是“最近刚访问的，将来访问的可能性比较大”
#### 5. 用过什么linux命令？
>答：软件安装apt-get install update upgrade
>系统信息:uptime whoami last date w who
>文件系统：cd pwd mkdir rmdir whereis find
>因为比较少在linux上开发，所以用的比较少
#### 6. 什么是内存碎片？
>答：内部碎片：是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就产生了内部碎片，通常内部碎片难以避免
>外部碎片：是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的分配请求，从而不能被进程利用的内存区域
>办法：段页式内存分配方式，将进程的内存区域分为不同的段，然后将每一段由多个固定大小的页组成。通过页表机制，使段内的页可以不必连续处于同一内存区域，从而减少外部碎片，同一页仍然可能存在少量的内部碎片，但是页的内存空间本身就小，所以内部碎片也比较少
#### 7. 大端/小端机器？
>答：区别是指低位数据在内存低位还是高位的区别。小端机器是数据低位存储在内存地址低位，大端相反
#### 8. 多线程优缺点？
>【适用场景：耗时或大量占用处理器的任务阻塞用户界面操作、各个任务必须等待外部资源】
>答：优点：
>1）多线程技术使程序的响应更快
>2） 占用大量处理时间段额任务使用多线程可以提高CPU利用率
>3） 多线程可以分别设置优先级以优化性能
>缺点：
>1）等待使用共享资源时造成的程序运行速度变慢
>2） 对线程进行管理要求额外的CPU开销，线程的使用会给系统带来上下文切换的额外负担
>3） 线程的死锁。共享资源加锁实现同步的过程中可能会出现死锁。
>4） 对公有变量的同时读或写，可能造成脏读等。
#### 9. 用户线程和内核线程的区别？
>答：内核线程建立和销毁都是由操作系统负责、通过系统调用完成的，用户线程是不需要内核支持而且在用户程序中实现的线程。
>用户线程的优点：
>1）可以在不支持线程的操作系统中实现
>2） 创建和销毁、切换线程代价比内核线程少
>3） 允许每个进程定制自己的调度算法，线程管理更灵活
>4） 线程能够利用表空间和堆栈空间比内核级多
>用户线程的缺点：
>1）同一进程只能有一个线程运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起
>2） 页面失效会导致整个进程被挂起
#### 10. 什么是虚拟内存？
> 答：是计算机系统内存管理的一种技术，它相对于物理内存而言，是“假的”，让程序认为它有一块完成的连续的地址空间，实际上，是由多个物理内存碎片组成，还有部分暂时存储在外部磁盘存储器
> 优点：
> 1）扩大地址空间。段氏虚存、页式虚存、段页式虚存寻址空间逗比实存大
> 2） 内存保护。每个进程运行在各自的虚拟内存空间互不干扰，另外虚存还对特定的内存地址提供写保护，防止代码或数据被恶意篡改
> 3） 公平分配内存。每个进程都相当于同样大小的虚存空间
> 4） 当进程需要通信时，可以采用虚存共享的方式实现
> 代价：
> 1）虚存管理需要建立很多数据结构，占额外的内存
> 2） 虚拟地址到物理地址的转换，增加了指令的执行时间
> 3） 页面的换入换出需要磁盘I/O，很耗时
> 4） 如果一页只有一部分数据，浪费内存
